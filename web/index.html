<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="style.css">
  <title>PocketCHIP – WebUI</title>
</head>

<body>
<div class="wrap">
  <header>
    <div class="brand">
      <h1>PocketCHIP – WebUI</h1>
      <p>Minimal, offline, ressourcenschonend (usb0 only)</p>
    </div>

    <div class="pill" title="Frontend-Status (nur UI)">
      <span id="uiDot" class="dot"></span>
      <span id="uiState">Bereit</span>
    </div>
  </header>

  <div class="grid">
    <!-- Card 1 -->
    <section class="card">
      <div class="hd">
        <h2>CDC Base</h2>
        <p>Immer aktiv, sobald USB angeschlossen ist (usb0=192.168.7.1/24 + DHCP).</p>
      </div>
      <div class="bd">
        <div class="kv">
          <div>Adresse</div><div><code>192.168.7.1</code></div>
          <div>Port</div><div><code>80</code></div>
        </div>
        <div class="hint">Hinweis: CDC Base wird nicht per UI ausgeschaltet.</div>
      </div>
    </section>

    <!-- Card 2 -->
    <section class="card">
      <div class="hd">
        <h2>CDC Internet Sharing</h2>
        <p>Hier schaltest du nur Routing/NAT (usb0 → uplink) ein/aus.</p>
      </div>
      <div class="bd">
        <div class="btnrow">
          <button type="button" class="secondary" onclick="run('status')">Status</button>
          <button type="button" onclick="run('on')">Internet an</button>
          <button type="button" class="danger" onclick="run('off')">Internet aus</button>
          <button type="button" class="secondary" onclick="run('shutdown')">Shutdown</button>
        </div>

        <div id="out" class="out">Bereit.</div>
        <div class="hint">Tipp: Auf Mobile sind die Buttons bewusst groß für Touch.</div>
      </div>
    </section>

    <!-- Card 3 -->
    <section class="card">
      <div class="hd">
        <h2>WLAN</h2>
        <p>Scan / Toggle / Verbinden (NetworkManager via nmcli)</p>
      </div>

      <div class="bd">
        <div class="row">
          <button type="button" onclick="wifiStatus()">Status</button>
          <button type="button" class="secondary" onclick="wifiScan()">Scan</button>
          <button type="button" class="secondary" onclick="wifiOn()">WLAN an</button>
          <button type="button" class="secondary" onclick="wifiOff()">WLAN aus</button>
        </div>

        <div class="row" style="margin-top:12px;">
          <input id="ssid" placeholder="SSID" style="flex:2; padding:10px; border-radius:8px; border:1px solid #ccc;">
          <input id="pass" placeholder="Passwort (leer = offen)" type="password" style="flex:2; padding:10px; border-radius:8px; border:1px solid #ccc;">
          <button type="button" class="secondary" onclick="wifiConnect()">Verbinden</button>
        </div>

        <pre id="wifiOut">Bereit.</pre>
        <small class="hint">Hinweis: Passwort wird per POST gesendet (nicht in URL), aber trotzdem: nur über usb0 erreichbar.</small>
      </div>
    </section>

    <!-- Card 4 -->
    <section class="card">
      <div class="hd">
        <h2>Sniffer (tcpdump)</h2>
        <p>PCAP-Mitschnitt zur Analyse. Rotiert automatisch; optional Cleanup (älter als 7 Tage).</p>
      </div>

      <div class="bd">
        <div class="row">
          <button type="button" onclick="tcpdumpCtl('status')">Status</button>
          <button type="button" onclick="tcpdumpCtl('start')">Start</button>
          <button type="button" class="secondary" onclick="tcpdumpCtl('stop')">Stop</button>
          <button type="button" class="secondary" onclick="capturesRefresh()">Captures</button>
          <button type="button" class="secondary" onclick="capturesCleanup(7)">Cleanup (7 Tage)</button>
          <button type="button" class="secondary" onclick="openSnifferLive()">Live</button>
        </div>

        <pre id="snifferOut">Bereit.</pre>
        <pre id="snifferOut">Bereit.</pre>

  <div class="hint" style="margin-top:8px;">
    Zeige neueste Captures:
    <select id="capLimit" onchange="capturesRefresh()">
      <option value="10">10</option>
      <option value="30" selected>30</option>
      <option value="50">50</option>
      <option value="100">100</option>
    </select>
  </div>

  <div style="margin-top:10px; overflow:auto; max-height:260px; border:1px solid #ddd; border-radius:10px;">
    <table style="width:100%; border-collapse:collapse;">
      <thead>
        <tr>
          <th style="text-align:left; padding:8px; border-bottom:1px solid #ddd;">Datei</th>
          <th style="text-align:right; padding:8px; border-bottom:1px solid #ddd;">Größe</th>
          <th style="text-align:right; padding:8px; border-bottom:1px solid #ddd;">Zeit</th>
          <th style="text-align:right; padding:8px; border-bottom:1px solid #ddd;">Download</th>
        </tr>
      </thead>
      <tbody id="capturesBody">
        <tr><td colspan="4" style="padding:10px;">Keine Daten</td></tr>
      </tbody>
    </table>
  </div>

  <small class="hint">Captures liegen unter <code>/captures/</code>.</small>
      </div>
    </section>

    <!-- Card: NextDNS -->
    <section class="card">
      <div class="hd">
        <h2>NextDNS</h2>
        <p>DNS-Filter (ein/aus) + lokale Logs.</p>
      </div>

      <div class="bd">
        <div class="row">
          <button type="button" onclick="nextdns('status')">Status</button>
          <button type="button" onclick="nextdns('on')">Ein</button>
          <button type="button" class="danger" onclick="nextdns('off')">Aus</button>
          <button type="button" class="secondary" onclick="nextdns('logs')">Logs</button>
        </div>

        <pre id="nextdnsOut">Bereit.</pre>
        <small class="hint">Hinweis: Logs kommen aus <code>journalctl -u nextdns</code>.</small>
      </div>
    </section>
  </div>

  <div class="footer">
    Minimal gehalten (busybox httpd + CGI). Keine externen Assets.
  </div>
</div>

<script>
  function $(id){ return document.getElementById(id); }

  function setUi(state){
    const dot = $('uiDot');
    const txt = $('uiState');
    if (!dot || !txt) return;

    txt.textContent = state;

    dot.classList.remove('ok','err');
    if(state === 'OK') dot.classList.add('ok');
    else if(state === 'FEHLER') dot.classList.add('err');
  }

  async function api(path, opts){
    const r = await fetch(path, Object.assign({ cache:'no-store' }, opts||{}));
    return await r.text();
  }

  async function run(action){
    const out = $('out');
    setUi('Läuft…');
    if (out) out.textContent = 'Läuft…\n';

    try{
      const r = await fetch('/cgi-bin/cdc.cgi?action=' + encodeURIComponent(action), { cache: 'no-store' });
      const t = await r.text();
      if (out) out.textContent = t || '(leer)';
      setUi((r.ok && !/^ERROR:/m.test(t)) ? 'OK' : 'FEHLER');
    }catch(e){
      if (out) out.textContent = 'FEHLER: ' + (e && e.message ? e.message : e);
      setUi('FEHLER');
    }
  }

  // WLAN
  async function wifiStatus(){
    $('wifiOut').textContent = 'Läuft…';
    $('wifiOut').textContent = await api('/cgi-bin/wifi.cgi?action=status');
  }

  async function wifiScan(){
    $('wifiOut').textContent = 'Scanne…';
    const txt = await api('/cgi-bin/wifi.cgi?action=scan');

    // Erwartet Zeilen im Format: "*:SSID:SECURITY:SIGNAL" oder ":SSID:SECURITY:SIGNAL"
    const lines = txt.trim().split('\n').filter(Boolean);
    const pretty = lines.map(l => {
      const parts = l.split(':');
      if(parts.length < 4) return l;
      const inuse = parts[0] === '*' ? '[*]' : '[ ]';
      const ssid = parts[1] || '<hidden>';
      const sec  = parts[2] || '--';
      const sig  = parts[3] || '';
      return `${inuse} ${ssid}  (${sec})  ${sig}%`;
    }).join('\n');

    $('wifiOut').textContent = pretty || txt;
  }

  async function wifiOn(){
    $('wifiOut').textContent = 'Schalte WLAN an…';
    $('wifiOut').textContent = await api('/cgi-bin/wifi.cgi?action=on');
  }

  async function wifiOff(){
    $('wifiOut').textContent = 'Schalte WLAN aus…';
    $('wifiOut').textContent = await api('/cgi-bin/wifi.cgi?action=off');
  }

  async function wifiConnect(){
    const ssid = $('ssid').value.trim();
    const pass = $('pass').value;

    if(!ssid){
      $('wifiOut').textContent = 'ERROR: SSID fehlt';
      return;
    }

    $('wifiOut').textContent = 'Verbinde…';

    const body = new URLSearchParams({ ssid, pass }).toString();
    const txt = await api('/cgi-bin/wifi.cgi?action=connect', {
      method: 'POST',
      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
      body
    });

    $('wifiOut').textContent = txt;
  }

  // NextDNS (nur einmal definiert, mit Fehlerbehandlung)
  async function nextdns(action){
    const out = document.getElementById('nextdnsOut');
    out.textContent = 'Läuft…';
    try{
      const r = await fetch('/cgi-bin/nextdns.cgi?action=' + encodeURIComponent(action), { cache: 'no-store' });
      out.textContent = await r.text();
    }catch(e){
      out.textContent = 'Fehler: ' + (e && e.message ? e.message : e);
    }
  }

  // Sniffer Live (SSE)
  function openSnifferLive(){
    const w = window.open('', 'snifferLive', 'width=900,height=600');
    w.document.write(`
    <title>Sniffer Live</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
      body{font-family:sans-serif;margin:12px}
      pre{background:#111;color:#eee;padding:12px;border-radius:8px;white-space:pre-wrap}
      .row{display:flex;gap:8px;align-items:center;margin-bottom:10px}
      button{padding:10px 12px;border:1px solid #ccc;border-radius:8px;background:#fff;cursor:pointer}
    </style>
    <div class="row">
      <button id="btnStop">Stop</button>
      <div id="st">Verbinde…</div>
    </div>
    <pre id="log"></pre>
  `);

    const log = w.document.getElementById('log');
    const st  = w.document.getElementById('st');
    const es  = new w.EventSource('/cgi-bin/sniffer-live.cgi');

    es.onmessage = (ev) => {
      log.textContent = ev.data + "\n" + log.textContent;
      st.textContent = 'Live…';
    };
    es.addEventListener('end', () => {
      st.textContent = 'Beendet';
      es.close();
    });
    es.onerror = () => {
      st.textContent = 'Verbindung beendet/Fehler (neu öffnen zum reconnect)';
      es.close();
    };

    w.document.getElementById('btnStop').onclick = () => {
      st.textContent = 'Gestoppt';
      es.close();
    };
  }

  // tcpdump Control (cgi-bin/tcpdump.cgi)
  async function tcpdumpCtl(action){
    const out = $('snifferOut');
    if (out) out.textContent = 'Läuft…';

    try{
      const r = await fetch('/cgi-bin/tcpdump.cgi?action=' + encodeURIComponent(action) + '&iface=wlan0', { cache: 'no-store' });
      const j = await r.json();

      if (out) out.textContent = `${j.action} (${j.iface}): ${j.result}`;
      if (action === 'start' || action === 'stop' || action === 'status') {
        await capturesRefresh();
      }
    }catch(e){
      if (out) out.textContent = 'Fehler: ' + (e && e.message ? e.message : e);
    }
  }

  function fmtBytes(n){
    if (!Number.isFinite(n)) return '-';
    const u = ['B','KB','MB','GB'];
    let i = 0;
    while(n >= 1024 && i < u.length-1){ n/=1024; i++; }
    return (i===0 ? n.toFixed(0) : n.toFixed(1)) + ' ' + u[i];
  }

  function fmtTime(epoch){
    if(!epoch) return '-';
    return new Date(epoch*1000).toLocaleString();
  }

  async function capturesRefresh(){
    const box = $('snifferLinks');
    if (box) box.textContent = 'Lade Captures…';

    try{
      const r = await fetch('/cgi-bin/captures.cgi?action=list&limit=30', { cache:'no-store' });
      const j = await r.json();
      if(!j.ok){
        if (box) box.textContent = 'Fehler: ' + (j.error || 'unbekannt');
        return;
      }

      const caps = j.captures || [];
      if(caps.length === 0){
        if (box) box.textContent = '(keine Captures)';
        return;
      }

      // Linkliste rendern
      const lines = caps.map(c => {
        const href = '/captures/' + encodeURIComponent(c.name);
        return `- ${c.name}  (${fmtBytes(Number(c.size))}, ${fmtTime(Number(c.mtime))})\n  ${location.origin}${href}`;
      }).join('\n');

      if (box) box.textContent = lines;
    }catch(e){
      if (box) box.textContent = 'Fehler: ' + (e && e.message ? e.message : e);
    }
  }

  async function capturesCleanup(days){
    const out = $('snifferOut');
    if (out) out.textContent = 'Cleanup läuft…';

    try{
      const r = await fetch('/cgi-bin/captures.cgi?action=cleanup&days=' + encodeURIComponent(String(days)), { cache:'no-store' });
      const j = await r.json();
      if(out){
        out.textContent = j.ok
          ? `Cleanup: ${j.deleted} Datei(en) gelöscht (>${j.days} Tage)`
          : `Cleanup-Fehler: ${j.error || 'unbekannt'}`;
      }
      await capturesRefresh();
    }catch(e){
      if (out) out.textContent = 'Fehler: ' + (e && e.message ? e.message : e);
    }
  }

  // Initialer Auto-Status
  document.addEventListener('DOMContentLoaded', () => {
    run('status');
    tcpdumpCtl('status');
    capturesRefresh();
  });
</script>
</body>
</html>
