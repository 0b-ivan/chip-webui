<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="style.css">
  <title>PocketCHIP – WebUI</title>
</head>

<body>
<div class="wrap">
  <header>
    <div class="brand">
      <h1>PocketCHIP – WebUI</h1>
      <p>Minimal, offline, ressourcenschonend (usb0 only)</p>
    </div>

    <div class="pill" title="Frontend-Status (nur UI)">
      <span id="uiDot" class="dot"></span>
      <span id="uiState">Bereit</span>
    </div>
  </header>

  <div class="grid">
    <!-- Card 1 -->
    <section class="card">
      <div class="hd">
        <h2>CDC Base</h2>
        <p>Immer aktiv, sobald USB angeschlossen ist (usb0=192.168.7.1/24 + DHCP).</p>
      </div>
      <div class="bd">
        <div class="kv">
          <div>Adresse</div><div><code>192.168.7.1</code></div>
          <div>Port</div><div><code>80</code></div>
        </div>
        <div class="hint">Hinweis: CDC Base wird nicht per UI ausgeschaltet.</div>
      </div>
    </section>

    <!-- Card 2 -->
    <section class="card">
      <div class="hd">
        <h2>CDC Internet Sharing</h2>
        <p>Hier schaltest du nur Routing/NAT (usb0 → uplink) ein/aus.</p>
      </div>
      <div class="bd">
        <div class="btnrow">
          <button type="button" class="secondary" onclick="run('status')">Status</button>
          <button type="button" onclick="run('on')">Internet an</button>
          <button type="button" class="danger" onclick="run('off')">Internet aus</button>
          <button type="button" class="secondary" onclick="run('shutdown')">Shutdown</button>
        </div>

        <div id="out" class="out">Bereit.</div>
        <div class="hint">Tipp: Auf Mobile sind die Buttons bewusst groß für Touch.</div>
      </div>
    </section>

    <!-- Card 3 -->
    <section class="card">
      <div class="hd">
        <h2>WLAN</h2>
        <p>Scan / Toggle / Verbinden (NetworkManager via nmcli)</p>
      </div>

      <div class="bd">
        <div class="row">
          <button type="button" onclick="wifiStatus()">Status</button>
          <button type="button" class="secondary" onclick="wifiScan()">Scan</button>
          <button type="button" class="secondary" onclick="wifiOn()">WLAN an</button>
          <button type="button" class="secondary" onclick="wifiOff()">WLAN aus</button>
        </div>

        <div class="row" style="margin-top:12px;">
          <input id="ssid" placeholder="SSID" style="flex:2; padding:10px; border-radius:8px; border:1px solid #ccc;">
          <input id="pass" placeholder="Passwort (leer = offen)" type="password" style="flex:2; padding:10px; border-radius:8px; border:1px solid #ccc;">
          <button type="button" class="secondary" onclick="wifiConnect()">Verbinden</button>
        </div>

        <pre id="wifiOut">Bereit.</pre>
        <small class="hint">Hinweis: Passwort wird per POST gesendet (nicht in URL), aber trotzdem: nur über usb0 erreichbar.</small>
      </div>
    </section>

    <!-- Card 4: Sniffer (tcpdump) -->
    <section class="card">
      <div class="hd">
        <h2>Sniffer (tcpdump)</h2>
        <p>PCAP-Mitschnitt zur Analyse. Rotiert automatisch; optional Cleanup (älter als 7 Tage).</p>
      </div>

      <div class="bd">
        <div class="row">
          <button type="button" onclick="tcpdumpCtl('status')">Status</button>
          <button type="button" onclick="tcpdumpCtl('start')">Start</button>
          <button type="button" class="secondary" onclick="tcpdumpCtl('stop')">Stop</button>
          <button type="button" class="secondary" onclick="tcpdumpRefresh()">Captures</button>
          <button type="button" class="secondary" onclick="tcpdumpCleanup(7)">Cleanup (7 Tage)</button>
          <button type="button" class="secondary" onclick="openSnifferLive()">Live</button>
        </div>

        <pre id="tcpdumpOut">Bereit.</pre>

        <div class="hint">Zeige neueste Captures: <span id="tcpdumpLimit">30</span></div>
        <div style="overflow:auto;">
          <table id="tcpdumpTable" class="tbl">
            <thead>
              <tr>
                <th>Datei</th>
                <th>Größe</th>
                <th>Zeit</th>
                <th>Download</th>
              </tr>
            </thead>
            <tbody id="tcpdumpTbody">
              <tr><td colspan="4">Keine Daten</td></tr>
            </tbody>
          </table>
        </div>

        <small class="hint">Captures liegen unter <code>/captures/</code>.</small>
      </div>
    </section>

    <!-- Card: NextDNS -->
    <section class="card">
      <div class="hd">
        <h2>NextDNS</h2>
        <p>DNS-Filter (ein/aus) + lokale Logs.</p>
      </div>

      <div class="bd">
        <div class="row">
          <button type="button" onclick="nextdns('status')">Status</button>
          <button type="button" onclick="nextdns('on')">Ein</button>
          <button type="button" class="danger" onclick="nextdns('off')">Aus</button>
          <button type="button" class="secondary" onclick="nextdns('logs')">Logs</button>
        </div>

        <pre id="nextdnsOut">Bereit.</pre>
        <small class="hint">Hinweis: Logs kommen aus <code>journalctl -u nextdns</code>.</small>
      </div>
    </section>
    <!-- Card: Hotspot -->
    <section class="card">
      <div class="hd">
        <h2>Hotspot</h2>
        <p>AP-Modus für den USB-WLAN-Dongle (hostapd + dnsmasq)</p>
      </div>

      <div class="bd">
        <div class="row">
          <button type="button" onclick="hotspotStatus()">Status</button>
          <button type="button" onclick="hotspotOn()">Hotspot an</button>
          <button type="button" class="danger" onclick="hotspotOff()">Hotspot aus</button>
        </div>

        <div class="row" style="margin-top:12px;">
          <input id="apSsid" placeholder="Hotspot-SSID" style="flex:2; padding:10px; border-radius:8px; border:1px solid #ccc;">
          <input id="apPass" placeholder="Passwort (min. 8 Zeichen, leer = offen*)" type="password" style="flex:2; padding:10px; border-radius:8px; border:1px solid #ccc;">
          <button type="button" class="secondary" onclick="hotspotSave()">Speichern</button>
        </div>

        <pre id="hotspotOut">Bereit.</pre>
        <small class="hint">*Offen nur, wenn du das im Backend erlaubst.</small>
      </div>
    </section>

  </div>

  <div class="footer">
    Minimal gehalten (busybox httpd + CGI). Keine externen Assets.
  </div>
</div>

<script>
  function $(id){ return document.getElementById(id); }

  function setUi(state){
    const dot = $('uiDot');
    const txt = $('uiState');
    if (!dot || !txt) return;

    txt.textContent = state;
    dot.classList.remove('ok','err');
    if(state === 'OK') dot.classList.add('ok');
    else if(state === 'FEHLER') dot.classList.add('err');
  }

  async function apiText(path, opts){
    const r = await fetch(path, Object.assign({ cache:'no-store' }, opts||{}));
    return await r.text();
  }

  async function run(action){
    const out = $('out');
    setUi('Läuft…');
    if (out) out.textContent = 'Läuft…\n';

    try{
      const r = await fetch('/cgi-bin/cdc.cgi?action=' + encodeURIComponent(action), { cache: 'no-store' });
      const t = await r.text();
      if (out) out.textContent = t || '(leer)';
      setUi((r.ok && !/^ERROR:/m.test(t)) ? 'OK' : 'FEHLER');
    }catch(e){
      if (out) out.textContent = 'FEHLER: ' + (e && e.message ? e.message : e);
      setUi('FEHLER');
    }
  }

  // WLAN
  async function wifiStatus(){
    $('wifiOut').textContent = 'Läuft…';
    $('wifiOut').textContent = await apiText('/cgi-bin/wifi.cgi?action=status');
  }

  async function wifiScan(){
    $('wifiOut').textContent = 'Scanne…';
    const txt = await apiText('/cgi-bin/wifi.cgi?action=scan');

    const lines = txt.trim().split('\n').filter(Boolean);
    const pretty = lines.map(l => {
      const parts = l.split(':');
      if(parts.length < 4) return l;
      const inuse = parts[0] === '*' ? '[*]' : '[ ]';
      const ssid = parts[1] || '<hidden>';
      const sec  = parts[2] || '--';
      const sig  = parts[3] || '';
      return `${inuse} ${ssid}  (${sec})  ${sig}%`;
    }).join('\n');

    $('wifiOut').textContent = pretty || txt;
  }

  async function wifiOn(){
    $('wifiOut').textContent = 'Schalte WLAN an…';
    $('wifiOut').textContent = await apiText('/cgi-bin/wifi.cgi?action=on');
  }

  async function wifiOff(){
    $('wifiOut').textContent = 'Schalte WLAN aus…';
    $('wifiOut').textContent = await apiText('/cgi-bin/wifi.cgi?action=off');
  }

  async function wifiConnect(){
    const ssid = $('ssid').value.trim();
    const pass = $('pass').value;

    if(!ssid){
      $('wifiOut').textContent = 'ERROR: SSID fehlt';
      return;
    }

    $('wifiOut').textContent = 'Verbinde…';

    const body = new URLSearchParams({ ssid, pass }).toString();
    const txt = await apiText('/cgi-bin/wifi.cgi?action=connect', {
      method: 'POST',
      headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
      body
    });

    $('wifiOut').textContent = txt;
  }

  // NextDNS
  async function nextdns(action){
    const out = $('nextdnsOut');
    out.textContent = 'Läuft…';
    try{
      const r = await fetch('/cgi-bin/nextdns.cgi?action=' + encodeURIComponent(action), { cache: 'no-store' });
      out.textContent = await r.text();
    }catch(e){
      out.textContent = 'Fehler: ' + (e && e.message ? e.message : e);
    }
  }

  // Sniffer Live (SSE)
  function openSnifferLive(){
    const w = window.open('', 'snifferLive', 'width=900,height=600');
    w.document.write(`
    <title>Sniffer Live</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
      body{font-family:sans-serif;margin:12px}
      pre{background:#111;color:#eee;padding:12px;border-radius:8px;white-space:pre-wrap}
      .row{display:flex;gap:8px;align-items:center;margin-bottom:10px}
      button{padding:10px 12px;border:1px solid #ccc;border-radius:8px;background:#fff;cursor:pointer}
    </style>
    <div class="row">
      <button id="btnStop">Stop</button>
      <div id="st">Verbinde…</div>
    </div>
    <pre id="log"></pre>
  `);

    const log = w.document.getElementById('log');
    const st  = w.document.getElementById('st');
    const es  = new w.EventSource('/cgi-bin/sniffer-live.cgi');

    es.onmessage = (ev) => {
      log.textContent = ev.data + "\n" + log.textContent;
      st.textContent = 'Live…';
    };
    es.addEventListener('end', () => {
      st.textContent = 'Beendet';
      es.close();
    });
    es.onerror = () => {
      st.textContent = 'Verbindung beendet/Fehler (neu öffnen zum reconnect)';
      es.close();
    };

    w.document.getElementById('btnStop').onclick = () => {
      st.textContent = 'Gestoppt';
      es.close();
    };
  }

  // -------- tcpdump (cgi-bin/tcpdump.cgi) + Captures-Listing ohne captures.cgi --------
  const TCPDUMP_IFACE_DEFAULT = 'wlan0';
  const TCPDUMP_LIMIT_DEFAULT = 30;

  async function tcpdumpCtl(action, iface){
    iface = (iface || TCPDUMP_IFACE_DEFAULT).trim();
    const out = $('tcpdumpOut');
    if (out) out.textContent = 'Läuft…';

    try{
      const r = await fetch('/cgi-bin/tcpdump.cgi?action=' + encodeURIComponent(action) + '&iface=' + encodeURIComponent(iface), { cache:'no-store' });
      const j = await r.json();
      if (out) out.textContent = `${j.action} (${j.iface}): ${j.result}`;

      // Nach Aktionen Liste aktualisieren
      if(action === 'start' || action === 'stop' || action === 'status'){
        await tcpdumpRefresh();
      }
    }catch(e){
      if (out) out.textContent = 'Fehler: ' + (e && e.message ? e.message : e);
    }
  }

  function fmtBytes(n){
    if (!Number.isFinite(n) || n < 0) return '-';
    const u = ['B','KB','MB','GB'];
    let i = 0;
    while(n >= 1024 && i < u.length-1){ n/=1024; i++; }
    return (i===0 ? n.toFixed(0) : n.toFixed(1)) + ' ' + u[i];
  }

  function fmtTimeMs(ms){
    if(!Number.isFinite(ms) || ms <= 0) return '-';
    return new Date(ms).toLocaleString();
  }

  function renderCapturesTable(items){
    const tbody = $('tcpdumpTbody');
    if(!tbody) return;

    tbody.innerHTML = '';
    if(!items || items.length === 0){
      tbody.innerHTML = '<tr><td colspan="4">Keine Daten</td></tr>';
      return;
    }

    for(const it of items){
      const tr = document.createElement('tr');

      const tdName = document.createElement('td');
      tdName.textContent = it.name || '-';

      const tdSize = document.createElement('td');
      tdSize.textContent = it.sizeText || '-';

      const tdTime = document.createElement('td');
      tdTime.textContent = it.timeText || '-';

      const tdDl = document.createElement('td');
      const a = document.createElement('a');
      a.href = it.href;
      a.textContent = 'Download';
      a.setAttribute('download', '');
      tdDl.appendChild(a);

      tr.appendChild(tdName);
      tr.appendChild(tdSize);
      tr.appendChild(tdTime);
      tr.appendChild(tdDl);

      tbody.appendChild(tr);
    }
  }

  function extractCaptureNamesFromText(txt){
    // Robust: unterstützt "files:"-Block und fallback per Regex
    const names = new Set();

    const lines = (txt || '').split('\n');
    const idx = lines.findIndex(l => l.trim() === 'files:');
    if(idx >= 0){
      for(let i = idx+1; i < lines.length; i++){
        const s = lines[i].trim();
        if(!s) continue;
        if(s.endsWith(':')) break;
        // häufige Formate: usb0-....pcap0 / tcpdump-wlan0-....pcap / .pcap1 etc.
        if(/\.(pcap|cap)\d*$/i.test(s)) names.add(s);
      }
    }

    // Regex fallback
    const re = /\b[\w.-]+\.(?:pcap|cap)\d*\b/gi;
    let m;
    while((m = re.exec(txt || ''))){
      names.add(m[0]);
    }

    return Array.from(names);
  }

  async function headInfoForCapture(name){
    const href = '/captures/' + encodeURIComponent(name);
    try{
      const r = await fetch(href, { method:'HEAD', cache:'no-store' });
      const len = r.headers.get('content-length');
      const lm  = r.headers.get('last-modified');

      const size = (len != null) ? Number(len) : NaN;
      const time = (lm != null) ? Date.parse(lm) : NaN;

      return {
        name,
        href,
        size,
        time,
        sizeText: Number.isFinite(size) ? fmtBytes(size) : '-',
        timeText: Number.isFinite(time) ? fmtTimeMs(time) : '-'
      };
    }catch(_e){
      return { name, href, sizeText:'-', timeText:'-' };
    }
  }

  async function snifferTextList(limit){
    // Wir benutzen absichtlich sniffer.cgi als Quelle, weil captures.cgi bei dir nicht existiert.
    // Falls action=captures nicht implementiert ist, fällt es auf action=status zurück.
    limit = Number(limit || TCPDUMP_LIMIT_DEFAULT);

    const tryUrls = [
      '/cgi-bin/sniffer.cgi?action=captures&limit=' + encodeURIComponent(String(limit)),
      '/cgi-bin/sniffer.cgi?action=list&limit=' + encodeURIComponent(String(limit)),
      '/cgi-bin/sniffer.cgi?action=status'
    ];

    let lastText = '';
    for(const url of tryUrls){
      try{
        const r = await fetch(url, { cache:'no-store' });
        lastText = await r.text();
        if(lastText && extractCaptureNamesFromText(lastText).length > 0) return lastText;
      }catch(_e){
        // continue
      }
    }
    return lastText;
  }

  async function tcpdumpRefresh(){
    const out = $('tcpdumpOut');
    const limitEl = $('tcpdumpLimit');
    const limit = Number(limitEl ? limitEl.textContent : TCPDUMP_LIMIT_DEFAULT) || TCPDUMP_LIMIT_DEFAULT;

    // UI state
    if(out && (!out.textContent || out.textContent.trim() === 'Bereit.')){
      out.textContent = 'Lade Captures…';
    }

    try{
      const txt = await snifferTextList(limit);
      const names = extractCaptureNamesFromText(txt);

      // Sortiere nach Name (typisch steckt Timestamp im Namen) absteigend
      names.sort().reverse();

      const limited = names.slice(0, limit);

      // HEAD-Infos holen (parallel)
      const infos = await Promise.all(limited.map(headInfoForCapture));

      renderCapturesTable(infos);

      // Wenn wir vorher "Lade..." gesetzt haben und jetzt fertig sind, nicht alles überschreiben:
      if(out && out.textContent === 'Lade Captures…'){
        out.textContent = 'Bereit.';
      }
    }catch(e){
      renderCapturesTable([]);
      if(out) out.textContent = 'Fehler beim Laden: ' + (e && e.message ? e.message : e);
    }
  }

  async function tcpdumpCleanup(days){
    days = Number(days || 7);
    const out = $('tcpdumpOut');
    out.textContent = 'Cleanup läuft…';

    // Wenn du (optional) bereits einen Cleanup in sniffer.cgi hast, nutzen wir ihn.
    // Wenn nicht vorhanden, bekommst du die Fehlermeldung sauber angezeigt.
    try{
      const r = await fetch('/cgi-bin/sniffer.cgi?action=cleanup&days=' + encodeURIComponent(String(days)), { cache:'no-store' });
      const t = await r.text();
      out.textContent = t && t.trim() ? t.trim() : `Cleanup ausgeführt (>${days} Tage)`;
    }catch(e){
      out.textContent = 'Cleanup-Fehler: ' + (e && e.message ? e.message : e);
    }

    await tcpdumpRefresh();
  }

  // Initial
  document.addEventListener('DOMContentLoaded', () => {
    run('status');
    tcpdumpCtl('status');
    tcpdumpRefresh();
  });
</script>
</body>
</html>